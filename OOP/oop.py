# '''
# Обзор терминологии ООП

#     Класс – определенный пользователем прототип для объекта, который определяет набор атрибутов, которые характеризуют любой объект класса. Атрибуты являются членами данных (переменные класса и переменные экземпляра) и методы, доступ к которым  с помощью запись через точку.
#     Переменная класса – переменная, которая разделяется всеми экземплярами класса. Переменные класса определяются в пределах класса, но не в любом методе класса. Переменные класса не используются так часто, как переменные экземпляра.
#     Элемент данных – класс переменной или экземпляра переменной, которая содержит данные, связанные с классом и его объектами.
#     Перегрузка функций – присвоение более одного поведения определенной функции. Выполняемая операция зависит от типов задействованных объектов или аргументов.
#     Переменная экземпляра – переменная, определенная внутри метода и относится только к текущему экземпляру класса.
#     Наследование – передача характеристик одного класса к другим классам, которые являются производными от него.
#     Экземпляр – индивидуальный объект определенного класса. Объект OBJ, который принадлежит к классу Circle, например, является экземпляром класса Circle.
#     Instantiation – создание экземпляра класса.
#     Метод – особый вид функции, который определяется в определении класса.
#     Объект – уникальный экземпляр структуры данных, который определяется его классом. Объект включает в себя как элементы данных (переменные класса и переменные экземпляра) и методы.
# '''


# '''
# Python поддерживает объектно-ориентированную парадигму программирования, а это значит, что мы можем определить компоненты программы в виде классов.

# Класс является шаблоном или формальным описанием объекта, а объект представляет экземпляр этого класса, его реальное воплощение. Можно провести следующую аналогию: у всех у нас есть некоторое представление о человеке - наличие двух рук, двух ног, головы, пищеварительной, нервной системы, головного мозга и т.д. Есть некоторый шаблон - этот шаблон можно назвать классом. Реально же существующий человек (фактически экземпляр данного класса) является объектом этого класса.

# С точки зрения кода класс объединяет набор функций и переменных, которые выполняют определенную задачу. Функции класса еще называют методами. Они определяют поведение класса. А переменные класса называют атрибутами- они хранят состояние класса

# Класс определяется с помощью ключевого слова class:
# '''


# class название_класса:
#     методы_класса


# '''
# Для создания объекта класса используется следующий синтаксис:
# '''

# название_объекта = название_класса([параметры])

# '''
# Например, определим простейший класс Person, который будет представлять человека:
# '''



# class Person:
#     name = "Aybek"
 
#     def display_info(self):
#         print("Привет, меня зовут", self.name)
 
# person1 = Person()
# person1.display_info()         # Привет, меня зовут Aybek
 
# person2 = Person()
# person2.name = "Nursultan"
# person2.display_info()         # Привет, меня зовут Nursultan


# #####     Конструкторы    #####

# '''
# Для создания объекта класса используется конструктор. Так, выше когда мы создавали объекты класса Person, мы использовали конструктор по умолчанию, который неявно имеют все классы:
# '''


# person1 = Person()
# person2 = Person()

# '''
# Однако мы можем явным образом определить в классах конструктор с помощью специального метода, который называется __init(). К примеру, изменим класс Person, добавив в него конструктор:
# '''

class Person:
 
    # конструктор
    def __init__(self, name, surname):
        self.name = name  # устанавливаем имя
        self.surname = surname

    def display_info(self):
        print("Привет, меня зовут", self.name,  self.surname)
 
# person1 = Person("Aybek", "Sapashov")
# # person1.display_info()         # Привет, меня зовут Aybek
# person2 = Person("Nursultan", "Karpov")
# person2.display_info()         # Привет, меня зовут Nursultan



# '''
# В качестве первого параметра конструктор также принимает ссылку на текущий объект - self. Нередко в конструкторах устанавливаются атрибуты класса. Так, в данном случае в качестве второго параметра в конструктор передается имя пользователя, которое устанавливается для атрибута self.name. Причем для атрибута необязательно определять в классе переменную name, как это было в предыдущей версии класса Person. Установка значения self.name = name уже неявно создает атрибут name.
# '''

# person1 = Person("Tom")
# person2 = Person("Sam", "Jonson")


# ####     Деструктор     #####

# '''
# После окончания работы с объектом мы можем использовать оператор del для удаления его из памяти:
# '''


# person1 = Person("Tom", "Johns")
# del person1     # удаление из памяти
# # person1.display_info()  # Этот метод работать не будет, так как person1 уже удален из памяти
# person2.display_info()

# '''
# Стоит отметить, что в принципе это необязательно делать, так как после окончания работы скрипта все объекты автоматически удаляются из памяти.

# Кроме того, мы можем определить определить в классе деструктор, реализовав встроенную функцию __del__, который будет вызываться либо в результате вызова оператора del, либо при автоматическом удалении объекта. Например:
# '''


# class Person:

#     # конструктор
#     def __init__(self, name):
#         self.name = name  # устанавливаем имя
 
#     def __del__(self):
#         print(self.name,"удален из памяти")

#     def display_info(self):
#         print("Привет, меня зовут", self.name)
 
 
# person1 = Person("Aybek")
# person1.display_info()  # Привет, меня зовут Aybek
# del person1     # удаление из памяти
# # person1.display_info()
# person2 = Person("Nursultan")
# person2.display_info()  # Привет, меня зовут Nursultan


# #####    Определение классов в модулях и подключение    ####

# '''
# Как правило, классы размещаются в отдельных модулях и затем уже импортируются в основой скрипт программы. Пусть у нас будет в проекте два файла: файл main.py (основной скрипт программы) и classes.py (скрипт с определением классов).
# '''

# '''
# В дополнение к классу Person здесь также определен класс Auto, который представляет машину и который имеет метод move и атрибут name. Подключим эти классы и используем их в скрипте main.py:
# '''

# from classes import Person, Auto 
 
# tom = Person("Tom")
# tom.display_info()
 
# bmw = Auto("BMW")
# bmw.move(65)


# ######    Аргумент self     ######


# '''
# Рассмотрим зачем нужен и что означает self в функциях Python. Как можно было заметить, единственным атрибутом для метода из класса является ключевое слово self. Помещать его нужно в каждую функцию чтобы иметь возможность вызвать ее на текущем объекте. Также с помощью этого ключевого слова можно получать доступ к полям класса в описываемом методе. Self таким образом заменяет идентификатор объекта.
# '''

# class Dog:
#     name = "Charlie"
#     noise = "Woof!"

#     def makeNoise(self):
#         print(self.name + " says: " + self.noise + " " + self.noise)
    
    
# dog = Dog()
# dog.makeNoise()


# '''
# Вверху представлен класс Dog, описывающий собаку. Он обладает полями name (имя) со стартовым значением «Charlie» и noise (шум), содержащим звук, который издает животное. Метод makeNoise заставляет собаку лаять, выдавая соответствующее сообщение на экран. Для этого в функции print используется получение доступа к полям name и noise. Далее необходимо создать экземпляр класса Dog и вызвать на нем makeNoise.
# '''




# #####    Доступ к атрибутам     #####


# class Employee:
#    'Общий базовый класс для всех сотрудников'
#    empCount = 0

#    def __init__(self, name, salary):
#       self.name = name
#       self.salary = salary
#       Employee.empCount += 1
   
#    def displayCount(self):
#      print ("Всего сотрудников %d" % Employee.empCount)

#    def displayEmployee(self):
#       print ("Имя : ", self.name,  ", Зарплата: ", self.salary)

# empl = Employee("Erjan", 20)
# empl2 = Employee("Myktybek", 15)
# empl.displayCount()
# empl.displayEmployee()
# empl2.displayEmployee()


# '''
# Вы можете получить доступ к атрибутам объекта, используя оператор точка с объектом. Переменная класса получит доступ, используя имя класса следующим образом:
# '''

# emp1.displayEmployee()
# emp2.displayEmployee()
# print ("Всего сотрудников %d" % Employee.empCount)



# #Это создаст первый объект класса сотрудника"
# emp1 = Employee("AndreyEx", 80000)
# #Это позволит создать второй объект класса employee"
# emp2 = Employee("Alex", 65000)
# emp1.displayEmployee()
# emp2.displayEmployee()
# print ("Всего сотрудников %d" % Employee.empCount)


# '''
# Вы можете добавлять, удалять или изменять атрибуты классов и объектов в любое время:
# '''

# emp1.salary = 7000  # Add an 'salary' attribute.
# emp1.name = 'xyz'  # Modify 'age' attribute.
# del emp1.salary  # Delete 'age' attribute.


# '''
# Вместо того, чтобы использовать обычные заявления атрибутов доступа, вы можете использовать следующие функции:

#     GetAttr (объект, имя [, по умолчанию]) – для доступа к атрибуту объекта.
#     Hasattr (объект, имя) – проверить, существует атрибут или нет.
#     SetAttr (объект, имя, значение) – установить атрибут. Если атрибут не существует, то он будет создан.
#     Delattr (объект, имя) – для удаления атрибута.
# '''

# hasattr(emp1, 'salary')    # Возвращает true, если атрибут 'salary' существует
# getattr(emp1, 'salary')    # Возвращает значение атрибута 'salary'
# setattr(emp1, 'salary', 7000) # Устанавливает атрибут 'salary' в 70000
# delattr(emp1, 'salary')    # Удаляет атрибут 'salary'


# #####     Встроенные атрибуты класса    ######


# '''
# Каждый класс Python поддерживает следующие встроенные атрибуты и их можно получить с помощью оператора точки, как и любой другой атрибут:

#     __dict__ – Словарь, содержащий пространство имен класса.
#     __doc__ – Документация класса string или нет, если не определено.
#     __name__ – Имя класса.
#     __module__ – Имя модуля, в котором определен класс. Это атрибут «__main__» в интерактивном режиме.
#     __bases__ – Возможно пустой кортеж, содержащий базовые классы, в порядке их появления в списке базового класса.

# Для приведенного выше класса давайте попробуем открыть все эти атрибуты:
# '''


# class Employee:
#    'Общий базовый класс для всех сотрудников'
#    empCount = 0

#    def __init__(self, name, salary):
#       self.name = name
#       self.salary = salary
#       Employee.empCount += 1
   
#    def displayCount(self):
#      print ("Всего сотрудников %d" % Employee.empCount)

#    def displayEmployee(self):
#       print ("Имя : ", self.name,  ", Зарплата: ", self.salary)

# emp1 = Employee("AndreyEx", 80000)
# emp2 = Employee("Alex", 65000)
# print ("Employee.__doc__:", Employee.__doc__)
# print ("Employee.__name__:", Employee.__name__)
# print ("Employee.__module__:", Employee.__module__)
# print ("Employee.__bases__:", Employee.__bases__)
# print ("Employee.__dict__:", Employee.__dict__ )


# #####     Уничтожение объектов (Garbage Collection)    ######

# '''
# Python удаляет ненужные объекты (встроенные типы или экземпляры классов) автоматически, чтобы освободить место в памяти. Процесс, посредством которого Python периодически восстанавливает блоки памяти, которые больше не находятся в использовании называется как сборщики мусора.

# Сборщик мусора в Python работают во время выполнения программы и срабатывают, когда счетчик ссылок объекта достигает нуля. Счетчик ссылок объекта изменяется, как число псевдонимов, которые указывают на ее изменения.

# Счетчик ссылок объекта увеличивается, когда ему присваивается новое имя или помещается в контейнер (список, кортеж, или словарь). Счетчик ссылок объекта уменьшается, когда он удаляется с del, его ссылка переназначается, или его ссылка выходит из области видимости. Когда счетчик ссылок объекта достигает нуля, Python собирает его автоматически.
# '''

# a = 40      # Создание объекта <40>
# b = a       # Увеличение счетчика ссылок <40> 
# c = [b]     # Увеличение счетчика ссылок <40> 

# del a       # Уменьшение счетчика ссылок <40>
# b = 100     # Уменьшение счетчика ссылок <40> 
# c[0] = -1   # Уменьшение счетчика ссылок <40>


# '''
# Как правило, вы не замечаете, когда сборщик мусора уничтожает обнулившийся экземпляр и высвобождает его пространство. Тем не менее, класс может реализовать специальный метод  __del __(), называется деструктор, который вызывается, когда экземпляр собирается быть уничтоженным. Этот метод может быть использован для очистки любых ресурсов из памяти, используемых экземпляр.
# '''

# '''
# Деструктор __del __ () печатает имя класса экземпляра, который собирается быть уничтожен:
# '''

# class Point:
#    def __init__( self, x=0, y=0):
#       self.x = x
#       self.y = y
#    def __del__(self):
#       class_name = self.__class__.__name__
#       print (class_name, "destroyed")

# pt1 = Point()
# pt2 = pt1
# pt3 = pt1
# print (id(pt1), id(pt2), id(pt3));   # печатает идентификаторы obejcts
# del pt1
# del pt2
# del pt3


# Classssessss

# class Person:
 
#     # конструктор
#     def __init__(self, name):
#         self.name = name  # устанавливаем имя
 
#     def display_info(self):
#         print("Привет, меня зовут", self.name)
 
 
# class Auto:
#     def __init__(self, name):
#         self.name = name
 
#     def move(self, speed):
#         print(self.name, "едет со скоростью", speed, "км/ч")

