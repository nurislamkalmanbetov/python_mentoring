# 1. Конвертер массы
# Создан класс KgToPounds с параметром kg, куда передается определенное количество килограмм, а с помощью метода to_pounds() они переводятся в фунты. Чтобы закрыть доступ к переменной kg реализованы методы set_kg() – для задания нового значения килограммов, get_kg() – для вывода текущего значения кг. Из-за этого возникло неудобство: нам нужно теперь использовать эти 2 метода для задания и вывода значений. Помогите переделать класс с использованием свойств-декораторов @property. Код приведен ниже.



# 2. Треугольник
# Требуется проверить, возможно ли из представленных отрезков условной длины сформировать треугольник. Для этого создайте класс TriangleChecker, принимающий только положительные числа. С помощью метода is_triangle() возвращаются следующие значения (в зависимости от ситуации):

# Ура, можно построить треугольник!
# С отрицательными числами ничего не выйдет!
# Жаль, но из этого треугольник не сделать.



# 3. Алфавит
# Описание классовой структуры
# Есть Алфавит, характеристиками которого являются:

# Язык
# Список букв
# Для Алфавита можно:

# Напечатать все буквы алфавита
# Посчитать количество букв
# Так же есть Английский алфавит, который обладает следующими свойствами:

# Язык
# Список букв
# Количество букв
# Для Английского алфавита можно:

# Посчитать количество букв
# Определить, относится ли буква к английскому алфавиту
# Получить пример текста на английском языке
# Задание
# Класс Alphabet
# Создайте класс Alphabet
# Создайте метод __init__(), внутри которого будут определены два атрибута: 1) lang – язык и 2) letters – список букв. Начальные значения свойств берутся из входных параметров метода
# Создайте метод print(), который выведет в консоль буквы алфавита
# Создайте метод letters_num(), который вернет количество букв в алфавите
# Класс EngAlphabet
# Создайте класс EngAlphabet путем наследования от класса Alphabet
# Создайте метод __init__(), внутри которого будет вызываться родительский метод __init__(). В качестве параметров ему будут передаваться обозначение языка (например, En) и строка, состоящая из всех букв алфавита (можно воспользоваться свойством ascii_uppercase из модуля string)
# Добавьте приватный статический атрибут _letters_num, который будет хранить количество букв в алфавите.
# Создайте метод is_en_letter(), который будет принимать букву в качестве параметра и определять, относится ли эта буква к английскому алфавиту.
# Переопределите метод letters_num() – пусть в текущем классе классе он будет возвращать значение атрибута _letters_num
# Создайте статический метод example(), который будет возвращать пример текста на английском языке.
# Тесты (main)
# Создайте объект класса EngAlphabet
# Напечатайте буквы алфавита для этого объекта
# Выведите количество букв в алфавите
# Проверьте, относится ли буква F к английскому алфавиту
# Проверьте, относится ли буква Щ к английскому алфавиту
# Выведите пример текста на английском языке

___________________________________________________________
#1
class KgToPounds:

    def init(self, kg):
        self.__kg = kg

    def to_pounds(self):
        return self.__kg * 2.205

    def set_kg(self, new_kg):
        if isinstance(new_kg, (int, float)):
            self.__kg = new_kg
        else:
            print('Килограммы задаются только числами')
    
    def get_kg(self):
        return self.__kg
_______________________________________________________________
Example:
# 1. Конвертер массы
# Создан класс KgToPounds с параметром kg, куда передается определенное количество килограмм, 
# а с помощью метода to_pounds() они переводятся в фунты. Чтобы закрыть доступ к переменной kg 
# реализованы методы set_kg() – для задания нового значения килограммов, get_kg() 
# – для вывода текущего значения кг. Из-за этого возникло неудобство: нам нужно теперь использовать 
# эти 2 метода для задания и вывода значений. Помогите переделать класс с использованием 
# свойств-декораторов @property. Код приведен ниже.
    
# class KgToPounds:
#     def __init__(self, kg):
#         self.__kg = kg

#     @property
#     def kg(self):
#         return self.__kg

#     @kg.setter
#     def kg(self, new_kg):
#         if isinstance(new_kg, (int, float)):
#             self.__kg = new_kg
#         else:
#             print('Килограммы задаются только числами')

#     def to_pounds(self):
#         return self.kg * 2.205
    
# # создание объекта
# ktp = KgToPounds(1)
# # получение текущего значения кг
# print(ktp.kg)  # 10
# # установка нового значения кг
# ktp.kg = 2
# # получение нового значения кг
# print(ktp.kg)  # 15
# # # конвертация кг в фунты
# print(ktp.to_pounds())  # 33.075
# _____________________________________________________________________________________________________

# 2. Треугольник
# Требуется проверить, возможно ли из представленных отрезков условной длины сформировать треугольник. 
# Для этого создайте класс TriangleChecker, принимающий только положительные числа. С помощью 
# метода is_triangle() возвращаются следующие значения (в зависимости от ситуации):
# Ура, можно построить треугольник!
# С отрицательными числами ничего не выйдет!
# Жаль, но из этого треугольник не сделать.
# class TriangleChecker(): 

#     def __init__(self, a, b, c) -> None:
#         if a > 0 and b > 0 and c > 0:
#             self.a = a
#             self.b = b
#             self.c = c
#         else:
#             raise ValueError("Длины отрезков должны быть положительными числами")
        
#     def is_triangle(self):
#         if self.a + self.b > self.c and self.b + self.c > self.a and self.c + self.a > self.b:
#             return "Ура, можно построить треугольник!"
#         else:
#             return "Жаль, но из этого треугольник не сделать."
        
# # создание объекта TriangleChecker 
# tc = TriangleChecker(10, 12, 15)
# # проверка, можно ли сформировать треугольник
# print(tc.is_triangle()) # "Ура, можно построить треугольник!"
# # создание объекта с отрицательными значениями
# # tc_neg = TriangleChecker(-3, 4, 5) # возбуждается исключение ValueError
# _____________________________________________________________________________________________________

# 3. Алфавит
# Описание классовой структуры
# Есть Алфавит, характеристиками которого являются:

# Язык
# Список букв
# Для Алфавита можно:

# Напечатать все буквы алфавита
# Посчитать количество букв
# Так же есть Английский алфавит, который обладает следующими свойствами:

# Язык
# Список букв
# Количество букв
# Для Английского алфавита можно:

# Посчитать количество букв
# Определить, относится ли буква к английскому алфавиту
# Получить пример текста на английском языке
# Задание
# Класс Alphabet
# Создайте класс Alphabet
# Создайте метод __init__(), внутри которого будут определены два атрибута: 
# 1) lang – язык и 
# 2) letters – список букв. Начальные значения свойств берутся из входных параметров метода
# Создайте метод print(), который выведет в консоль буквы алфавита
# Создайте метод letters_num(), который вернет количество букв в алфавите
# Класс EngAlphabet
# Создайте класс EngAlphabet путем наследования от класса Alphabet
# Создайте метод __init__(), внутри которого будет вызываться родительский метод __init__(). 
# В качестве параметров ему будут передаваться обозначение языка (например, En) и строка, 
# состоящая из всех букв алфавита (можно воспользоваться свойством ascii_uppercase из модуля string)
# Добавьте приватный статический атрибут _letters_num, который будет хранить количество букв в алфавите.
# Создайте метод is_en_letter(), который будет принимать букву в качестве параметра и определять, 
# относится ли эта буква к английскому алфавиту.
# Переопределите метод letters_num() – пусть в текущем классе классе он будет возвращать значение 
# атрибута _letters_num
# Создайте статический метод example(), который будет возвращать пример текста на английском языке.
# Тесты (main)
# Создайте объект класса EngAlphabet
# Напечатайте буквы алфавита для этого объекта
# Выведите количество букв в алфавите
# Проверьте, относится ли буква F к английскому алфавиту
# Проверьте, относится ли буква Щ к английскому алфавиту
# Выведите пример текста на английском языке